#+TITLE: ML for the Working Programmer

* Why SML?
For me, it is due to learning Isabelle more effectively; and also as I'm doing
SICP, the functional programming style would works for good.
* Resources
- [[https://www.cl.cam.ac.uk/~lp15/MLbook/pub-details.html][Text book (freely distributed in online)]]
* Study Note
** Chapter 2
*** Naming constants
We can name value by declaring with ML keywords ~val~
#+BEGIN_SRC sml
val seconds = 60;
#+END_SRC

#+RESULTS:
: val seconds = 60 : int
: END

Note that we have to begin with ~val~ and end with semicolon ~;~.
All the ML statement should end with ~;~ like above--similar to java.

For now, we can treat ML as calculator:
#+BEGIN_SRC sml
val pi = 3.14159;
val r = 2.0;
val area = pi * r * r;
#+END_SRC

#+RESULTS:
: val pi = 3.14159 : real
: val r = 2.0 : real
: val area = 12.56636 : real
: END

*** Declaring functions
we can capture the [[Naming constants][previous]] calculation as function:
#+BEGIN_SRC sml
fun area(r) = pi*r*r;
#+END_SRC

#+RESULTS:
: val area = fn : real -> real
: END

Then we can call it with argument:
#+BEGIN_SRC sml
area(2.0);
#+END_SRC

#+RESULTS:
: val it = 12.56636 : real
: END

The parentheses around the argument are optional:
#+BEGIN_SRC sml
area 1.0;
#+END_SRC

#+RESULTS:
: val it = 3.14159 : real
: END

It is also true when we declare the function:
#+BEGIN_SRC sml
fun area r = pi*r*r;
#+END_SRC

#+RESULTS:
: val area = fn : real -> real
: END

**** Comments
The comment's syntax in Standard ML begins with ~(*~ and ends with ~*)~, which
is same as Isabelle--Isabelle inherite this from SML more correctly.

It is important to put some comments for clarity of one's purpose (for that
purpose I've started literal programming in org mode like this.):
#+BEGIN_SRC sml
fun area r = (* area of circle with radius r *)
    pi*r*r;
#+END_SRC

Yeah, it looks silly to comment like this simple function; but when we make
a lot of abstract layers, it comes as big help.

*** Identifiers
It is allowed to use /symbolic names/ as identifies:
| symbolic names | ~! % & $ # + - * / : < = > ? @ \ ~ ` ^ *~ \vert |

So it is valid expression in ML:
#+BEGIN_SRC sml
val +-+ = 1415;
#+END_SRC

#+RESULTS:
: val +-+ = 1415 : int
: END

**** Exercise 2.1

For starting an ML session, use the command ~run-sml~.
#+BEGIN_SRC sml
use "exercise2_1.sml";
#+END_SRC
To terminate the REPL session, type ~<C-d>~,i.e. end of file.

*** Arithmetic
**** Integers
To type the negative integer, prepend the tilde to the digit:
#+BEGIN_SRC sml
~23
#+END_SRC

Integer operations are infix with conventional precedences, whereas scheme
(lisp) has prefix so that it doesn't need the concept of precedences.

**** Real numbers
A real constant contains ~E~ notation: ~E~ /n/ means times the /n/ th power of 10.
/n/ can be negative integer:
~123.4E~2~ denotes 1.234.

Note that function application binds more tightly than infix operators:
~area a + b~ is equivalent to ~(area a) + b~ not ~area (a + b)~.

**** Exercise 2.2
As ML is strictly typed language when we consider the real and integer numbers
as one unit, namely number, then we have some problems:
- We can not have integer division because we think integer as real number.
- We can not have remiander function; if it is, then it should work also to real
  numbers, which is certainly not what we wanted.


On the other hand, Lisp has dynamically typed language--weakly typed, it can
have the integer division and remainder procedures, which is specific to integer
numbers; basically Lisp also differentiate the real number and integer number
under the hood. So, it is not fair to say "ML should simply provide numbers, as
Lisp does \cdots "
**** Exercise 2.3
Let's do some experiment:
#+BEGIN_SRC sml
2 * 1.2
#+END_SRC

#+RESULTS:
:

which raises error says "Error: operator and operand do not agree [overload conflict]"

We can conclude from this that the integer number does not coerced to real number
automatically. So the ~fun double(n) = 2*n;~ doesn't need to specify the type
constraints because the ~2~ cast that ~n~ should be int unless it raises error
like above.

Second experiment:
#+BEGIN_SRC sml
Math.sin(1)
#+END_SRC

#+RESULTS:
: stdIn:1.2-5.4 Error: operator and operand do not agree [overload conflict]
: operator domain: real
: operand:         [int ty]
: in expression:
: Math.sin 1

which raises "Error: operator and operand do not agree [overload conflict]".

So we can deduce from this that ~Math.sin~ expect to take real as its argument's type.
As consequence, ~fun f~ also need not to be constrained.

On the other hands, the last one need to be constrained; ML can not deduce the
type of argument as ~*~ is overloaded function,i.e. it can be used with integer
as real as well.
*** Strings and characters
**** Exercise 2.4
- First version of function digit:
  #+BEGIN_SRC sml
fun digit i = chr(i + ord #"0");
  #+END_SRC

  #+RESULTS:
  : val digit = fn : int -> char
  : END

- Second version of function digit:
  #+BEGIN_SRC sml
fun digit i = String.sub("0123456789", i);
  #+END_SRC

  #+RESULTS:
  : [autoloading]
  : [library $SMLNJ-BASIS/basis.cm is stable]
  : [library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
  : [autoloading done]
  : val digit = fn : int -> char
  : END


I expect when we call the ~digit ~1~ in the second version of it, it should
returns error that says "invalid index" or something like that or it could
return "9" like python; but the function call of ~digit 10~ should raise invalid
index error without another choice.

On the other hand, the former may not raise error in ~digit 10~ call because it
obviously ranges in ASCII character set; but the other one should raise error as
I think the ASCII character set doesn't accept the negative character code.

So, let's check:
#+BEGIN_SRC sml
digit ~1;
digit 10;
#+END_SRC

#+RESULTS:
:
: uncaught exception Subscript [subscript out of bounds]
: raised at: stdIn:10.15-10.25

Uh-oh, the function call ~digit ~1~ of first version did not raise the error it
returns ~/~ ; it turns out accept negative integer as its code! Interesting.
And as expected the ~digit 10~ returns ~:~ not error.

How about the second one?; which raises error says "uncaught exception Subscript [subscript out of bounds]
" in both case as expected. Not like python huh.

*** Truth values and conditional expressions
**** Exercise 2.5
#+BEGIN_SRC sml
(m = "January" orelse m = "March" orelse m = "May" orelse m = "July" orelse m = "September" orelse m = "Nobember")
 andalso (0 < d andalso d < 32) orelse
 (m = "April" orelse m = "June" orelse m = "August" orelse m = "October" orelse m = "December") andalso
 (0 < d andalso d < 31) orelse (m = "February" andalso (0 < d andalso d < 29))
#+END_SRC

#+RESULTS:
: val it = true : bool
: END

*** Functions with multiple arguments and results
**** Exercise 2.6
To name it easily we use the abbreviation ~mytime~ as tuple of ~(hours, minutes, AM or PM)~:
#+BEGIN_SRC sml
type mytime = int * int * string;
#+END_SRC

#+RESULTS:
: type mytime = int * int * string
: END

Then we can define predicate which determine whether one time of day, in form of
~mytime~, comes before another. The behavior of it should follows
#+BEGIN_SRC sml
(11, 59, "AM") precedes (1, 15, "PM");
#+END_SRC

We can easily implement it:
#+BEGIN_SRC sml
fun isPrecedes((h1, m1, N1):mytime, (h2, m2, N2)) =
    (N1 = "AM" andalso N2 = "PM") orelse (h1 < h2) orelse (m1 < m2)
#+END_SRC

#+RESULTS:
: val isPrecedes = fn : mytime * (int * int * string) -> bool
: END

**** Exercise 2.7
#+BEGIN_SRC sml
type oldEngMoney = int * int * int;
fun oldEngMoneyAdd((po1,s1,pe1), (po2,s2,pe2)) =
    let val amount = ((po1 + po2)*20 + s1 + s2)* 12 + pe1 + pe2
    in (amount div (20 * 12), (amount mod (20 * 12)) div 12, amount mod 12)
    end

fun oldEngNeg(po, s, pe): oldEngMoney = (~po, ~s, ~pe)
fun oldEngMoneySub(money1, money2) = oldEngMoneyAdd(money1, oldEngNeg money2)
#+END_SRC

#+RESULTS:
: type oldEngMoney = int * int * int
: val oldEngMoneyAdd = fn : (int * int * int) * (int * int * int) -> oldEngMoney
: val oldEngNeg = fn : int * int * int -> oldEngMoney
: val oldEngMoneySub = fn : (int * int * int) * (int * int * int) -> oldEngMoney
: END

*** Raising to an integer power
**** Exercise 2.12

#+BEGIN_SRC latex
\begin{align}
  2.0^{29} &= 2.0 \times 2.0^{28} \\
  &= 2.0 \times 4.0^{14} \\
  &= 2.0 \times 16.0^{7} \\
  &= 2.0 \times (16.0 \times 16.0^{6}) \\
  &= 2.0 \times (16.0 \times 256.0^{3}) \\
  &= 2.0 \times (16.0 \times (256.0 \times 256.0^{2})) \\
  &= 2.0 \times (16.0 \times (256.0 \times 65536.0)) \\
  &= 2.0 \times (16.0 \times 16777216.0) \\
  &= 2.0 \times 268435456.0 \\
  &= 536870912.0
\end{align}
#+END_SRC

#+RESULTS:
#+begin_export latex
\begin{align}
2.0^{29} &= 2.0 \times 2.0^{28} \\
&= 2.0 \times 4.0^{14} \\
&= 2.0 \times 16.0^{7} \\
&= 2.0 \times (16.0 \times 16.0^{6}) \\
&= 2.0 \times (16.0 \times 256.0^{3}) \\
&= 2.0 \times (16.0 \times (256.0 \times 256.0^{2})) \\
&= 2.0 \times (16.0 \times (256.0 \times 65536.0)) \\
&= 2.0 \times (16.0 \times 16777216.0) \\
&= 2.0 \times 268435456.0 \\
&= 536870912.0
\end{align}
#+end_export

**** Exercise 2.13
The number of multiplications needed to compute ~power(x,k)~ is the number of
binary digit representing it plus the number of 1s in its binary digit except
the leftmost one.

So at most, the number of multiplications of it is 2 \times \log_{2} k - 1.

**** Exercise 2.14
Because we chose using ~div~ also in odd power reduction case, if we set the
base case as ~k=0~ and maintain the else unchanged, then when it comes to ~k=1~,
it should calculate ~x * x~, which never used for returning value and also the
most expensive multiplication in that process. To avoid it, we should take ~k=1~
as base case.

**** Exercise 2.15
The recursive definition of /F_{n}/ would be like this:
#+BEGIN_SRC sml
fun fib n: int =
    if n < 2 then n
    else fib (n-1) + fib (n-2);
#+END_SRC

In the above definition, we can not distinguish whether it is strict or
call-by-name rule evaluation; both results to exponential time complexity.
On the other hand, the lazy evaluation could help this situation: It could be
thought as memoization; it has same structure as /nextfib/.

So, lazy evaluation big win here.

**** Exercise 2.16
We can prove that the steps needed are less than 2^{n} and greather than
2^{n/2}. As consequence it inherite exponential step complexity.

To compute the exact number of steps needed for /F_{n}/, we need to solve the
linear discrete differential equation:

#+BEGIN_SRC latex
\begin{align}
f_{n} &= f_{n-1} + f_{n-2} + 2 &\text{for }n > 1 \\
f_{n} &= 1 &\text{for }n < 2
\end{align}
#+END_SRC

#+RESULTS:
#+begin_export latex
\begin{align}
f_{n} &= f_{n-1} + f_{n-2} + 2 &\text{for }n > 1 \\
f_{n} &= 1 &\text{for }n < 2
\end{align}
#+end_export


It is worth to solve eagerously; but I've done with in [[github:HyunggyuJang/SICP][SICP]]. So I like to skip
this step.

**** Exercise 2.17
By reduction step, we know that /itfib(n+1, F_{k-1}, F_{k})/ \to
/itfib(n, F_{k}, F_{k+1})/. Based on this, we can reason or observe by
experimenting some examples that /itfib(n,F_{k-1}, F_{k})/ \to
/F_{k+n-1}/. We can prove this fact by induction on n.
