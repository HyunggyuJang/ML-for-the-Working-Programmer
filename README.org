#+TITLE: ML for the Working Programmer

* Why SML?
For me, it is due to learning Isabelle more effectively; and also as I'm doing
SICP, the functional programming style would works for good.
* Resources
- [[https://www.cl.cam.ac.uk/~lp15/MLbook/pub-details.html][Text book (freely distributed in online)]]
* Study Note
** Chapter 2
*** Naming constants
We can name value by declaring with ML keywords ~val~
#+BEGIN_SRC sml
val seconds = 60;
#+END_SRC

#+RESULTS:
: val seconds = 60 : int
: END

Note that we have to begin with ~val~ and end with semicolon ~;~.
All the ML statement should end with ~;~ like above--similar to java.

For now, we can treat ML as calculator:
#+BEGIN_SRC sml
val pi = 3.14159;
val r = 2.0;
val area = pi * r * r;
#+END_SRC

#+RESULTS:
: val pi = 3.14159 : real
: val r = 2.0 : real
: val area = 12.56636 : real
: END

*** Declaring functions
we can capture the [[Naming constants][previous]] calculation as function:
#+BEGIN_SRC sml
fun area(r) = pi*r*r;
#+END_SRC

#+RESULTS:
: val area = fn : real -> real
: END

Then we can call it with argument:
#+BEGIN_SRC sml
area(2.0);
#+END_SRC

#+RESULTS:
: val it = 12.56636 : real
: END

The parentheses around the argument are optional:
#+BEGIN_SRC sml
area 1.0;
#+END_SRC

#+RESULTS:
: val it = 3.14159 : real
: END

It is also true when we declare the function:
#+BEGIN_SRC sml
fun area r = pi*r*r;
#+END_SRC

#+RESULTS:
: val area = fn : real -> real
: END

**** Comments
The comment's syntax in Standard ML begins with ~(*~ and ends with ~*)~, which
is same as Isabelle--Isabelle inherite this from SML more correctly.

It is important to put some comments for clarity of one's purpose (for that
purpose I've started literal programming in org mode like this.):
#+BEGIN_SRC sml
fun area r = (* area of circle with radius r *)
    pi*r*r;
#+END_SRC

Yeah, it looks silly to comment like this simple function; but when we make
a lot of abstract layers, it comes as big help.

*** Identifiers
It is allowed to use /symbolic names/ as identifies:
| symbolic names | ~! % & $ # + - * / : < = > ? @ \ ~ ` ^ * Â¦~ |

So it is valid expression in ML:
#+BEGIN_SRC sml
val +-+ = 1415;
#+END_SRC

#+RESULTS:
: val +-+ = 1415 : int
: END

**** Exercise 2.1

For starting an ML session, use the command ~run-sml~.
#+BEGIN_SRC sml
use "exercise2_1.sml";
#+END_SRC
To terminate the REPL session, type ~~,i.e. end of file.

*** Arithmetic
**** Integers
To type the negative integer, prepend the tilde to the digit:
#+BEGIN_SRC sml
~23
#+END_SRC

Integer operations are infix with conventional precedences, whereas scheme
(lisp) has prefix so that it doesn't need the concept of precedences.

**** Real numbers
A real constant contains ~E~ notation: ~E~ /n/ means times the /n/ th power of 10.
/n/ can be negative integer:
~123.4E\~2~ denotes 1.234.

Note that function application binds more tightly than infix operators:
~area a + b~ is equivalent to ~(area a) + b~ not ~area (a + b)~.

**** Exercise 2.2
As ML is strictly typed language when we consider the real and integer numbers
as one unit, namely number, then we have some problems:
- We can not have integer division because we think integer as real number.
- We can not have remiander function; if it is, then it should work also to real
  numbers, which is certainly not what we wanted.


On the other hand, Lisp has dynamically typed language--weakly typed, it can
have the integer division and remainder procedures, which is specific to integer
numbers; basically Lisp also differentiate the real number and integer number
under the hood. So, it is not fair to say "ML should simply provide numbers, as
Lisp does \cdots"
**** Exercise 2.3
Let's do some experiment:
#+BEGIN_SRC sml
2 * 1.2
#+END_SRC

#+RESULTS:
:

which raises error says "Error: operator and operand do not agree [overload conflict]"

We can conclude from this that the integer number does not coerced to real number
automatically. So the ~fun double(n) = 2*n;~ doesn't need to specify the type
constraints because the ~2~ cast that ~n~ should be int unless it raises error
like above.

Second experiment:
#+BEGIN_SRC sml
Math.sin(1)
#+END_SRC

#+RESULTS:
: stdIn:1.2-5.4 Error: operator and operand do not agree [overload conflict]
: operator domain: real
: operand:         [int ty]
: in expression:
: Math.sin 1

which raises "Error: operator and operand do not agree [overload conflict]".

So we can deduce from this that ~Math.sin~ expect to take real as its argument's type.
As consequence, ~fun f~ also need not to be constrained.

On the other hands, the last one need to be constrained; ML can not deduce the
type of argument as ~*~ is overloaded function,i.e. it can be used with integer
as real as well.
