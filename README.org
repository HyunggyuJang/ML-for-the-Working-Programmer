#+TITLE: ML for the Working Programmer

* Why SML?
For me, it is due to learning Isabelle more effectively; and also as I'm doing
SICP, the functional programming style would works for good.
* Resources
- [[https://www.cl.cam.ac.uk/~lp15/MLbook/pub-details.html][Text book (freely distributed in online)]]
* Study Note
** Chapter 2
*** Naming constants
We can name value by declaring with ML keywords ~val~
#+BEGIN_SRC sml
val seconds = 60;
#+END_SRC

#+RESULTS:
: val seconds = 60 : int
: END

Note that we have to begin with ~val~ and end with semicolon ~;~.
All the ML statement should end with ~;~ like above--similar to java.

For now, we can treat ML as calculator:
#+BEGIN_SRC sml
val pi = 3.14159;
val r = 2.0;
val area = pi * r * r;
#+END_SRC

#+RESULTS:
: val pi = 3.14159 : real
: val r = 2.0 : real
: val area = 12.56636 : real
: END

*** Declaring functions
we can capture the [[Naming constants][previous]] calculation as function:
#+BEGIN_SRC sml
fun area(r) = pi*r*r;
#+END_SRC

#+RESULTS:
: val area = fn : real -> real
: END

Then we can call it with argument:
#+BEGIN_SRC sml
area(2.0);
#+END_SRC

#+RESULTS:
: val it = 12.56636 : real
: END

The parentheses around the argument are optional:
#+BEGIN_SRC sml
area 1.0;
#+END_SRC

#+RESULTS:
: val it = 3.14159 : real
: END

It is also true when we declare the function:
#+BEGIN_SRC sml
fun area r = pi*r*r;
#+END_SRC

#+RESULTS:
: val area = fn : real -> real
: END

**** Comments
The comment's syntax in Standard ML begins with ~(*~ and ends with ~*)~, which
is same as Isabelle--Isabelle inherite this from SML more correctly.

It is important to put some comments for clarity of one's purpose (for that
purpose I've started literal programming in org mode like this.):
#+BEGIN_SRC sml
fun area r = (* area of circle with radius r *)
    pi*r*r;
#+END_SRC

Yeah, it looks silly to comment like this simple function; but when we make
a lot of abstract layers, it comes as big help.

*** Identifiers
It is allowed to use /symbolic names/ as identifies:
| symbolic names | ~! % & $ # + - * / : < = > ? @ \ ~ ` ^ *~ \vert |

So it is valid expression in ML:
#+BEGIN_SRC sml
val +-+ = 1415;
#+END_SRC

#+RESULTS:
: val +-+ = 1415 : int
: END

**** Exercise 2.1

For starting an ML session, use the command ~run-sml~.
#+BEGIN_SRC sml
use "exercise2_1.sml";
#+END_SRC
To terminate the REPL session, type ~<C-d>~,i.e. end of file.

*** Arithmetic
**** Integers
To type the negative integer, prepend the tilde to the digit:
#+BEGIN_SRC sml
~23
#+END_SRC

Integer operations are infix with conventional precedences, whereas scheme
(lisp) has prefix so that it doesn't need the concept of precedences.

**** Real numbers
A real constant contains ~E~ notation: ~E~ /n/ means times the /n/ th power of 10.
/n/ can be negative integer:
~123.4E~2~ denotes 1.234.

Note that function application binds more tightly than infix operators:
~area a + b~ is equivalent to ~(area a) + b~ not ~area (a + b)~.

**** Exercise 2.2
As ML is strictly typed language when we consider the real and integer numbers
as one unit, namely number, then we have some problems:
- We can not have integer division because we think integer as real number.
- We can not have remiander function; if it is, then it should work also to real
  numbers, which is certainly not what we wanted.


On the other hand, Lisp has dynamically typed language--weakly typed, it can
have the integer division and remainder procedures, which is specific to integer
numbers; basically Lisp also differentiate the real number and integer number
under the hood. So, it is not fair to say "ML should simply provide numbers, as
Lisp does \cdots "
**** Exercise 2.3
Let's do some experiment:
#+BEGIN_SRC sml
2 * 1.2
#+END_SRC

#+RESULTS:
:

which raises error says "Error: operator and operand do not agree [overload conflict]"

We can conclude from this that the integer number does not coerced to real number
automatically. So the ~fun double(n) = 2*n;~ doesn't need to specify the type
constraints because the ~2~ cast that ~n~ should be int unless it raises error
like above.

Second experiment:
#+BEGIN_SRC sml
Math.sin(1)
#+END_SRC

#+RESULTS:
: stdIn:1.2-5.4 Error: operator and operand do not agree [overload conflict]
: operator domain: real
: operand:         [int ty]
: in expression:
: Math.sin 1

which raises "Error: operator and operand do not agree [overload conflict]".

So we can deduce from this that ~Math.sin~ expect to take real as its argument's type.
As consequence, ~fun f~ also need not to be constrained.

On the other hands, the last one need to be constrained; ML can not deduce the
type of argument as ~*~ is overloaded function,i.e. it can be used with integer
as real as well.
*** Strings and characters
**** Exercise 2.4
- First version of function digit:
  #+BEGIN_SRC sml
fun digit i = chr(i + ord #"0");
  #+END_SRC

  #+RESULTS:
  : val digit = fn : int -> char
  : END

- Second version of function digit:
  #+BEGIN_SRC sml
fun digit i = String.sub("0123456789", i);
  #+END_SRC

  #+RESULTS:
  : [autoloading]
  : [library $SMLNJ-BASIS/basis.cm is stable]
  : [library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
  : [autoloading done]
  : val digit = fn : int -> char
  : END


I expect when we call the ~digit ~1~ in the second version of it, it should
returns error that says "invalid index" or something like that or it could
return "9" like python; but the function call of ~digit 10~ should raise invalid
index error without another choice.

On the other hand, the former may not raise error in ~digit 10~ call because it
obviously ranges in ASCII character set; but the other one should raise error as
I think the ASCII character set doesn't accept the negative character code.

So, let's check:
#+BEGIN_SRC sml
digit ~1;
digit 10;
#+END_SRC

#+RESULTS:
:
: uncaught exception Subscript [subscript out of bounds]
: raised at: stdIn:10.15-10.25

Uh-oh, the function call ~digit ~1~ of first version did not raise the error it
returns ~/~ ; it turns out accept negative integer as its code! Interesting.
And as expected the ~digit 10~ returns ~:~ not error.

How about the second one?; which raises error says "uncaught exception Subscript [subscript out of bounds]
" in both case as expected. Not like python huh.

*** Truth values and conditional expressions
**** Exercise 2.5
#+BEGIN_SRC sml
(m = "January" orelse m = "March" orelse m = "May" orelse m = "July" orelse m = "September" orelse m = "Nobember")
 andalso (0 < d andalso d < 32) orelse
 (m = "April" orelse m = "June" orelse m = "August" orelse m = "October" orelse m = "December") andalso
 (0 < d andalso d < 31) orelse (m = "February" andalso (0 < d andalso d < 29))
#+END_SRC

#+RESULTS:
: val it = true : bool
: END

*** Functions with multiple arguments and results
**** Exercise 2.6
To name it easily we use the abbreviation ~mytime~ as tuple of ~(hours, minutes, AM or PM)~:
#+BEGIN_SRC sml
type mytime = int * int * string;
#+END_SRC

#+RESULTS:
: type mytime = int * int * string
: END

Then we can define predicate which determine whether one time of day, in form of
~mytime~, comes before another. The behavior of it should follows
#+BEGIN_SRC sml
(11, 59, "AM") precedes (1, 15, "PM");
#+END_SRC

We can easily implement it:
#+BEGIN_SRC sml
fun isPrecedes((h1, m1, N1):mytime, (h2, m2, N2)) =
    (N1 = "AM" andalso N2 = "PM") orelse (h1 < h2) orelse (m1 < m2)
#+END_SRC

#+RESULTS:
: val isPrecedes = fn : mytime * (int * int * string) -> bool
: END

**** Exercise 2.7
#+BEGIN_SRC sml
type oldEngMoney = int * int * int;
fun oldEngMoneyAdd((po1,s1,pe1), (po2,s2,pe2)) =
    let val amount = ((po1 + po2)*20 + s1 + s2)* 12 + pe1 + pe2
    in (amount div (20 * 12), (amount mod (20 * 12)) div 12, amount mod 12)
    end

fun oldEngNeg(po, s, pe): oldEngMoney = (~po, ~s, ~pe)
fun oldEngMoneySub(money1, money2) = oldEngMoneyAdd(money1, oldEngNeg money2)
#+END_SRC

#+RESULTS:
: type oldEngMoney = int * int * int
: val oldEngMoneyAdd = fn : (int * int * int) * (int * int * int) -> oldEngMoney
: val oldEngNeg = fn : int * int * int -> oldEngMoney
: val oldEngMoneySub = fn : (int * int * int) * (int * int * int) -> oldEngMoney
: END

*** Raising to an integer power
**** Exercise 2.12

#+BEGIN_SRC latex
\begin{align}
  2.0^{29} &= 2.0 \times 2.0^{28} \\
  &= 2.0 \times 4.0^{14} \\
  &= 2.0 \times 16.0^{7} \\
  &= 2.0 \times (16.0 \times 16.0^{6}) \\
  &= 2.0 \times (16.0 \times 256.0^{3}) \\
  &= 2.0 \times (16.0 \times (256.0 \times 256.0^{2})) \\
  &= 2.0 \times (16.0 \times (256.0 \times 65536.0)) \\
  &= 2.0 \times (16.0 \times 16777216.0) \\
  &= 2.0 \times 268435456.0 \\
  &= 536870912.0
\end{align}
#+END_SRC

#+RESULTS:
#+begin_export latex
\begin{align}
2.0^{29} &= 2.0 \times 2.0^{28} \\
&= 2.0 \times 4.0^{14} \\
&= 2.0 \times 16.0^{7} \\
&= 2.0 \times (16.0 \times 16.0^{6}) \\
&= 2.0 \times (16.0 \times 256.0^{3}) \\
&= 2.0 \times (16.0 \times (256.0 \times 256.0^{2})) \\
&= 2.0 \times (16.0 \times (256.0 \times 65536.0)) \\
&= 2.0 \times (16.0 \times 16777216.0) \\
&= 2.0 \times 268435456.0 \\
&= 536870912.0
\end{align}
#+end_export

**** Exercise 2.13
The number of multiplications needed to compute ~power(x,k)~ is the number of
binary digit representing it plus the number of 1s in its binary digit except
the leftmost one.

So at most, the number of multiplications of it is 2 \times \log_{2} k - 1.

**** Exercise 2.14
Because we chose using ~div~ also in odd power reduction case, if we set the
base case as ~k=0~ and maintain the else unchanged, then when it comes to ~k=1~,
it should calculate ~x * x~, which never used for returning value and also the
most expensive multiplication in that process. To avoid it, we should take ~k=1~
as base case.

**** Exercise 2.15
The recursive definition of /F_{n}/ would be like this:
#+BEGIN_SRC sml
fun fib n: int =
    if n < 2 then n
    else fib (n-1) + fib (n-2);
#+END_SRC

In the above definition, we can not distinguish whether it is strict or
call-by-name rule evaluation; both results to exponential time complexity.
On the other hand, the lazy evaluation could help this situation: It could be
thought as memoization; it has same structure as /nextfib/.

So, lazy evaluation big win here.

**** Exercise 2.16
We can prove that the steps needed are less than 2^{n} and greather than
2^{n/2}. As consequence it inherite exponential step complexity.

To compute the exact number of steps needed for /F_{n}/, we need to solve the
linear discrete differential equation:

#+BEGIN_SRC latex
\begin{align}
f_{n} &= f_{n-1} + f_{n-2} + 2 &\text{for }n > 1 \\
f_{n} &= 1 &\text{for }n < 2
\end{align}
#+END_SRC

#+RESULTS:
#+begin_export latex
\begin{align}
f_{n} &= f_{n-1} + f_{n-2} + 2 &\text{for }n > 1 \\
f_{n} &= 1 &\text{for }n < 2
\end{align}
#+end_export


It is worth to solve eagerously; but I've done with in [[github:HyunggyuJang/SICP][SICP]]. So I like to skip
this step.

**** Exercise 2.17
By reduction step, we know that /itfib(n+1, F_{k-1}, F_{k})/ \to
/itfib(n, F_{k}, F_{k+1})/. Based on this, we can reason or observe by
experimenting some examples that /itfib(n,F_{k-1}, F_{k})/ \to
/F_{k+n-1}/. We can prove this fact by induction on n.

**** Exercise 2.18
Code iterative process of following process:
#+BEGIN_SRC sml
fun increase(k,n) = if (k+1)*(k+1) > n then k else k + 1;

fun introot n =
    if n = 0 then 0 else increase(2 * introot(n div 4), n);
#+END_SRC

#+BEGIN_SRC scheme
(define (quaternary n bit)
  (if (= n 0)
      bit
      (quaternary (quotient n 4) (cons (modulo n 4) bit))))

(define (increase root bit number)
  (if (null? bit)
      root
      (let ((next-root (* 2 root))
            (next-number (+ number (car bit)))
            (next-bit (cdr bit)))
        (increase
         (if (> (square(1+ next-root))
                (next-number))
             next-root
             (1+ next-root))
         next-bit
         (* 4 next-number)))))

(define (introot n)
  (increase 0 (quaternary n '()) 0))
#+END_SRC

This is the iterative process of ~introot~. We exploit the fact that ~introot~
is somewhat analogous to ~fast-expt~; whereas ~fast-expt~ look only the one bit
of number--represented by binary number, it need to look more than
that--sequence of quaternary number.

**** Exercise 2.19
We can code this algorithm:
#+BEGIN_SRC sml
fun gcd(m,n) =
    if m=n then m
    else if m mod 2 = 0 andalso n mod 2 = 0
    then 2 * gcd(m div 2, n div 2)
    else if m mod 2 = 1 andalso n mod 2 = 1
    then if m < n then gcd((n-m) div 2, m) else gcd((m-n) div 2, n)
    else if m mod 2 = 0
    then gcd(m div 2, n)
    else gcd(n div 2, m);
#+END_SRC

To compare with Euclid's Algorithm, we consider the following example:
~gcd(5499, 6812)~
- In Euclid's Algorithm, as did in text book, it require 6 steps.
- On the other hand, the given algorithm we should take 13 steps for evaluating it.


Can we prove that Euclid's Algorithm is always more efficient than given? The
given algorithm quite subtle so I think it is not easy to prove in this point.
After we gathered right instruments, we should try it not now.

**** Exercise 2.20
If we decide to nest ~itfib~ in ~fib~, then every call of fib should redefine
~itfib~ which is obvious overhead; in ~sqroot~ function, ~findroot~ depends on
the parameter of ~sqroot~, ~a~ and ~acc~ which does not change over the
iteration process, whereas ~itfib~ alter its parameters during iteration. So it
is ideal to define ~itfib~ using ~local~.
**** Exercise 2.21
Now I've got it what the statement intended: The point was ~introot~ maps /n/ to
its integer square root /k/ with the difference /n - k^{2}/; namely /n/ \to
/(k, n - k^{2}/ with /eliminating squaring operation/. Let's put the base case
first; and then put all the pieces together.

We can start with this:
#+BEGIN_SRC sml
fun introotpair n =
    if n < 4 then (1, n - 1)    (* base case *)
    else
        let val (i, dif) = introotpair (n div 4) (* wishful thinking assume we'v got *)
...
#+END_SRC

Then from the recursive step, we need to check
- whether n - (2i + 1)^{2} < 0; if it is then 2i would be integer root of n,
  otherwise 2i + 1.


Then we should maps this /2i/ and /n - (2i + 1)^{2} < 0/ in terms of ~i~,
~dif~ and /n/, where ~dif~ is m - i^{2}. We can solve this by observing that
- n - (2i + 1)^{2} = n - 4m + 4(m - i^{2}) - 4i - 1 = n - 4m + 4 ~dif~ - 4 ~i~ - 1
- n - 4m = ~n - 4 (n div 4)~ = ~n mod 4~


We converted as wanted. By putting together, we get
#+BEGIN_SRC sml
fun introotpair n =
    if n < 4 then (1, n - 1)    (* base case *)
    else
        let val (i, dif) = introotpair (n div 4) (* wishful thinking assume we've got *)
        in
            if (n mod 4) + 4 * dif - 4 * i - 1 < 0
            then (2*i, (n mod 4) + 4 * dif)
            else (2*i + 1, (n mod 4) + 4 * dif - 4 * i - 1)
        end;
#+END_SRC

Removing the duplicative evaluation, we get
#+BEGIN_SRC sml
fun introotpair n =
    if n < 4 then (1, n - 1)    (* base case *)
    else
        let val (i, dif) = introotpair (n div 4) (* wishful thinking assume we'v got *)
            val (k_1, dif_1) = (2*i, (n mod 4) + 4 * dif)
            val (k_2, dif_2) = (k_1 + 1, dif_1 - 2 * k_1 - 1)
        in
            if dif_2 < 0
            then (k_1, dif_1)
            else (k_2, dif_2)
        end;
#+END_SRC

*** Simultaneous declarations
In ML, the function definition capture the environment when it defined; so it
need special syntax for mutual recursion:
#+BEGIN_SRC sml
fun pos d = neg(d - 2.0) + 1.0/d
and neg d = if d>0.0 then pos(d-2.0) - 1.0/d
                     else 0.0;
#+END_SRC

Whereas, in scheme procedure definition did not bind its free variable when it
defined--it is called erroneously /closure/ property; there is no concept like
mutual recursion or special syntax for it, the above function definition can be
achieved likely:
#+BEGIN_SRC scheme
(define (pos d)
  (+ (neg (- d 2.0))
     (/ 1.0 d)))
(define (neg d)
  (if (> d 0)
      (- (pos (- d 2.0))
         (/ 1.0 d))
      0.0))
#+END_SRC
**** Exercise 2.22
It would swap the values because the left hand side of declaration only rewrite
its value after evaluated right hand side expressions.
**** Exercise 2.23
Let's code it directly: for the summation notation, declare auxilary function
named ~sum_P~. As both function are mutually dependent, we should use
simultaneous declaration:
#+BEGIN_SRC sml
fun P n =
    if n = 1 then 1
    else 1 + sum_P (n-1)
and sum_P n =
    if n = 0 then 0
    else P n + sum_P (n-1);
#+END_SRC
As this process evolve interwindly, we can prove that its step complextity is
exponential[fn:1] whereas space complextity is linear with repect to ~n~.
Also, we can optain the closed form of its return value, 2^{n-1} by solving
discrete linear differential equation with repect to ~sum_P~. In turns, this
closed form can be calculated in \log_{2} n complexity of steps by using ~fast-expt~.
**** Exercise 2.24
We can exploit the fact that ~fun~ is syntactic sugar for ~val~:
#+BEGIN_SRC sml
structure Real : ARITH =
struct
type t = real;
val zero = 0.0;
val sum : t * t -> t= op+;
val diff : t * t -> t= op-;
val prod : t * t -> t= op*;
val quo = op/;
end;
#+END_SRC
**** Exercise 2.25
Rational number arithmetic:
#+BEGIN_SRC sml
structure Rational : ARITH =
struct
type t = int * int;
val zero = (0, 1);
fun make_rat (n',d') =
    let val g = gcd(n', d')
        val (n, d) = (n' div g, d' div g)
    in
        if (n > 0 andalso d < 0) (* make denominator positive *)
               (* orelse (n < 0 andalso d < 0) *)
               (* ↑ this is can not happen by dividing gcd both side *)
        then (~n, ~d)
        else (n, d)
    end;
fun sum ((n,d), (n',d')) = make_rat(n * d' + n' * d, d * d');
fun neg (n,d) : t = (~n, d);
fun diff (r, r') = sum(r, neg r');
fun prod ((n,d), (n',d')) = make_rat(n*n', d*d');
fun recip (n, d) : t = (d, n);
fun quo (r, r') = prod (r, recip r');
end
#+END_SRC

As I commented, in the ~make_rat~ function definition, the ~orelse~ clause never
be evaluated as ~true~. So I've omitted it. At first glimpse it is not obvious
why; so maybe I shouldn't omit it for clarity of code. This is one's preference;
I like it.
**** Exercise 2.26
From the ~if n=1 then curr~ we (compiler) can infer that ~n~ is type of ~int~
and also that ~curr~ has ~int~ type by type constraints of ~itfib~. As
consequence, by ~prev + curr~ the ~prev~ also should have ~int~ type, ~itfib~'s
type are determined as ~int * int * int -> int~.
**** Exercise 2.27
Type check the following function declaration:
#+BEGIN_SRC sml
fun f (k,m) = if k=0 then 1 else f(k-1);
#+END_SRC

#+RESULTS:
: stdIn:21.34-21.40 Error: operator and operand do not agree [overload conflict]
: operator domain: [- ty] * 'Z
: operand:         [- ty]
: in expression:
: f (k - 1)
: END

By the type checking rule for conditional expression, ~f(k-1)~ has ~int~ type.
As ~k=0~ implies ~k~ is integer, ~f(k-1)~ means that it called with argument
type ~int~; but the function declaration denotes ~f~ should take pair as its
argument. So it end up with compilation error.

* Footnotes

[fn:1] By comparing with the recursive vesion of ~fib~.
